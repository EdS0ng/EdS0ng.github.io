---
layout: post
title:  "Node.js Processes and Threads"
date:   2015-11-22 16:03:45
---
&nbsp;&nbsp;&nbsp;&nbsp; Yesterday, I dug into a topic about Node that I feel isn't too well documented. That topic is how Node handles processes and threads. I dug into this topic partly due to curiosity, as I dislike using tools that I don't understand, but also as a necessity as I was working on something that required using the core child process module provided with Node. The information I found was quite interesting and I ended up spending a good amount of time learning about processes and threads. 

&nbsp;&nbsp;&nbsp;&nbsp; Now, Node itself provides two core modules for creating new processes, the cluster module and the child process module. The main functionality of the child process module is to provide users with an easy way to access the command line interface in Node. This then allows users to link Node apps to programs written in other languages as you can simply run a terminal command to execute a new program. Similarly, the cluster module allows users to easily create new Node processes that can all listen on the same server port. However, an important thing to note is that cluster.fork is built on top of the child process.fork method and is essentially the same method. You can do what cluster.fork does manually with child processes, it's just easier to use the cluster.fork when you need multiple Node processes running. Another important note about these two modules is that they both create processes, not threads. To my understanding, the difference between the two lies mainly in the "size" difference between the two. Threads are paths of execution within a process, they are essentially lightweight processes. A process is generally used to execute applications, and can be made up of multiple threads, in fact, most usually are. For example, a word processor uses multiple threads to take in user input as well as print the input onto the screen at the same time. Another important difference between threads and processes is in the communication aspect. Threads share the same address space as their siblings and have access to the same data structures and resources. This means that it is very easy for threads to communicate with each other. On the other hand, processes each have their own address space and are basically isolated from each other. Thus, communication between processes is much harder and requires more overhead. Similarly, starting a new process also requires more overhead than starting new threads and thus threads are usually more suited to smaller tasks. Now, the importance of this information with regards to Node is that there is no way for users to create new threads, only new processes. This means that users should be careful with the child process module and only use them when actually needed. 

&nbsp;&nbsp;&nbsp;&nbsp; Although users can only create new processes in Node, this doesn't mean that threads are non-existent in Node. While Node is commonly described as a single threaded event loop, this description is not fully accurate. The main event loop that Node runs on is indeed single threaded. However, in order to achieve asynchronous functionality, Node relies on the [libuv](https://github.com/libuv/libuv/) library. Libuv in turn, relies on a thread pool for all async I/O tasks, user code, and DNS operations. Thus, Node actually does use threads under the hood. The threads just aren't easily accessible to the user. Note that this is only for file based I/O, Node uses different async APIs for network I/O. 

&nbsp;&nbsp;&nbsp;&nbsp; Hopefully, this post will be helpful for some people looking to understand how Node achieves its asynchronous callback functionalities. Of course, there is still much more to it, but hopefully, I provided a decent starting point. Lastly, I want to post a [link](https://www.future-processing.pl/blog/on-problems-with-threads-in-node-js/) to an article I found very helpful, especially the diagrams. 